| ✍️ Tangxt | ⏳ 2020-08-11 | 🏷️ 总纲 |

# 01-Node.js 技术架构

> Node.js 是什么，以及它是由什么组成的！ -> 对于前端而言，关于底层 C++代码，只需要知道是做什么的，以及用到了哪些技术就行了！不需要去想这代码的逻辑是怎样的……

## ★引子

我先看了这个 [Node.js 基础篇](https://ppambler.github.io/nodejs/02/) （就看了视频的第一讲），但看完之后，我觉得这些知识点都是很零碎的，虽然内容都讲清楚了，但总觉得自己的脑海里并咩有对 Node.js 建立起一个总体性的认知，于是我就看了方方这节的免费课：[Node.js 全解及 Next.js 框架实践 - 写代码啦！](https://xiedaimala.com/courses/f0e0726e-6073-4b23-b590-387ff879f64a/random/1a2196ecc6#/common)

## ★JS 如何调用 C++

1）Node.js 版本

双数是稳定版，单数是非稳定版，我们使用 8 以上版本

> Vue 3.0 在 8 里用会有些小问题，而 10 就没问题了！

2）Node.js 安装

![安装](assets/img/2020-08-11-23-55-18.png)

3）周边工具

![开发工具](assets/img/2020-08-11-23-59-27.png)

4）Node.js 是什么？

> 讲 Node.js 是什么之前，先来讲讲 Node.js 不是什么……

1、Node.js 不是什么？

- **不是 Web 框架**
  - Node.js 并不是 web 后端框架
  - 所以你不能把 Node.js 与 Flask 或 Spring 对比
- **不是编程语言**
  - Node.js 并不是后端的 JS
  - 所以你不能把 Node.js 与 Python 或 PHP 对比

> 不要有这样的说辞「我该学 Node.js 好呢？还是 Python 好呢？」

2、Node.js 是什么？

- **是一个平台**
  - 它将多种技术组合起来了
  - 让 JavaScript 也能调用系统接口、开发后端应用
- Node.js 用到了哪些技术？
  - V8 引擎 -> 作者很牛逼，V1~V8 这 8 个虚拟机，而且这是不同语言的
  - libuv -> 非常有用的库，本来是 Node.js 作者写给自己用的，后来因为此库太有用了，所以导致了其它语言社区也在用这个库
  - C/C++ 实现的各种高性能的库： [c-ares](https://c-ares.haxx.se/)「实现 DNS 解析，域名的解析」、[http-parser](https://github.com/nodejs/http-parser)「解析 http」、[OpenSSL](https://www.openssl.org/)「搞 https」、[zlib](http://zlib.net/)「搞加密」等库

> 我们一般不区分 C 和 C++，因为它们俩都是可以通用的，说用 C 实现的高性能库也好，还是用 C++实现的高性能库也罢！

5）Node.js 技术架构

![Node.js 技术架构](assets/img/2020-08-12-10-37-00.png)

- [0.10 版本](https://github.com/nodejs/node/tree/v0.10.0-release)
- [node 代码分析](https://github.com/yjhjstz/deep-into-node)：作者用了多篇文章分析了 Node.js 的核心架构 -> 讲得非常详细

接下来，就介绍一下该架构图里边提到的一个个东西！

6）什么是 bindings？

![bindings 是什么](assets/img/2020-08-12-14-54-39.png)

Node.js 它调用了很多 C/C++的库，比如说 C++ 有一个库，叫 http_parser，它可以非常高效地处理 http 的一些内容，如它告诉你这部分是啥，下一部分是啥，每部分都有啥含义等等……

而我们在 Node.js 里，只能写 JS 呀！所以我们该如何调用 C/C++的库呢？

直接调？ -> 显然不行呀！JS 的数据类型与 C++的数据类型根本就不一样 -> 所以这根本就不存在一种直接调用的途径

那咋办呢？

Node.js 作者做了一些中间层的处理，封装了一些东西，如用 C++（必须用这门语言）对 http_parser 进行封装，使其能让 JS 的数据类型与 C++的数据类型统一化，如不管是`int/short/float……`还是啥的，都是`number`类型，都是一一对应的。

封装的结果就是「`http_parser_bindings.cpp`」（还有其它头文件）

总之，Node.js 作者为了让我们能够使用 `http_parser`，所以就写了一个 `http_parser_bindings.cpp`

除此之外，Node.js 还提供了一个编译工具，可以把 `http_parser_bindings.cpp` 编译成 `.node`这样的二进制文件或者可执行文件

我们的 JS 不能直接 require `.cpp`文件，但可以 require `.node`文件，这样一来，JS 就能调用 C++库了，而 Node.js 作者写的这个`http_parser_bindings.cpp`就叫做「binding」啦！

Node.js 作者除了封装 `http_parser` 这个库以外，还封装了其它库，也就是 Node.js 还提供了很多个`binding`，所以这就是「`bindings`」了！

由于是 Node.js 提供的 binding，所以全名就是「**Node.js bindings**」

回过头来看，Node.js 是如何使 JS 和 C/C++ 通信的呢？

> Node.js 在这中间加了一个个 C++ 模块，它可以使得这两者之间在数据类型上统一，以及其它方面的一些协调！

7）JS 与 C++交互

> Node.js 还提供了其它交互方式，我这里只举其中的一个例子

- JS 调用 C++代码： [官方示例 1](http://nodejs.cn/api/addons.html#addons_function_arguments)
- C++调用 JS 回调：[官方示例 2](http://nodejs.cn/api/addons.html#addons_callbacks)

如何用 JS 调用 C++（自顶向下）？如何用 C++调用 JS 的函数（自底向上）？

1、示例 1

上述示例 1 里边的内容是 Node.js 的插件内容——**告诉我们如何写一个 C++的库，以及如何用 JS 调用这个库！**

如你写了一个 `addon.cc`（不完全是 C 代码，夹杂着 C++代码，所以就说成是`C/C++`了） -> 编译它 -> 得到`.node`文件 -> 在 JS 里使用它`const addon = require('./build/Release/addon')`（可以省略`.node`后缀）

我们

``` js
addon.add(3, 5)
```

，其实就是做：

``` c++
// add 方法的实现
// args 是你传给 C++的参数数组，也就是类似 [3,5] 这种形式
void Add(const FunctionCallbackInfo<Value>& args) {
  // 如果你只传一个参数就报「参数的数量错误」返回给你 JS
  // 如果你传的不是 Number 类型的，那就报「参数错误」返回给你 JS
  // 两个检查都通过了，那就把俩参数加起来，得到了一个新的 Number 类型的值，然后返回给你 JS，这样 addon.add(3, 5) 就是一个 「8」的返回值
}
```

> 突然感觉，把 JS 数值类型的 `3` 和 `5` ，经过 `binding` **加工**后，变成了 C/C++ 可处理的类型，C/C++ 处理之后，返回了一个  `double` 类型的 `8`，然后再把 `8` 这个值通过 `binding` **过滤**成 JS 可以处理的 `Number`类型 `8`

我看了一下这个：

```c++
void Add(const FunctionCallbackInfo<Value>& args) {
   // 执行操作
  double value =
      args[0].As<Number>()->Value() + args[1].As<Number>()->Value();
  Local<Number> num = Number::New(isolate, value);

  // 设置返回值 （使用传入的 FunctionCallbackInfo<Value>&)。
  args.GetReturnValue().Set(num);
}
```

似乎 `Local<Number> num = Number::New(isolate, value);` 这一步就完成了`double` `8` 的数据类型转换……（`isolate`很复杂）

不管怎样，总体上看，`addon.add(3, 5)`就是在调用`addon.cc`里的`Add`函数（以后如果你想了解`add`这个函数是怎么写的，那么你就得看底层的`.cc`文件了！ -> 关于对象之间的通信：`addon`要做加法行为，被操作的对象是`3`和`5` -> `you.cut('hand')`双十一你要剁手，行为是「剁」，要「剁」的对象是「手」，而不是「脚」）

---

可以看到这个例子是可以证明 JS 是可以直接调用 C++的代码的！（不止是这一种方法可以做到！方方演示的是文档里写的方法）

---

2、示例 2

C++ 如何调用 JS 里的函数？

> 把 JavaScript 函数传入到一个 C++ 函数并在那里执行它们，这在插件里是常见的做法。

``` js
// test.js
const addon = require('./build/Release/addon');

addon((msg) => {
  console.log(msg);
// 打印：'hello world'
});
```

我们把一个 callback 作为一个参数传给了`addon`，我们 JS 并咩有调用`callback`！

![callback](assets/img/2020-08-12-17-10-11.png) 

C++内存里的`String`与 JS 的是不一样的，所以需要构造转化一下……搞成是 JS 能看懂的`String`

C++底层的`addon`执行，其函数体内`cb -> Call("hello world")` -> 也就是把`"hello world"`传给了上层的`(msg) => {console.log(msg)}`去调用 -> 说白了，就是底层抛一个数据给上层的`msg`

> 一个疑问：是底层就执行了`callback`，`log`一个`"hello world"`，还是 把数据抛给上层的 JS，然后交给 `v8` 引擎自己去执行 `callback`？

我觉得是在底层调的`callback`！毕竟`addon`这个函数是 C/C++ 写的！ -> 似乎 V8 引擎就是 C/C++ 写的，所以执行 C/C++ 代码时，应该也是由 V8 引擎做的吧……

> 额，我似乎遗忘了 Node.js 提供的**编译工具**，我们为 Node.js 写 C/C++ 插件，其实得要按照某种要求来写，编译工具把写好的`xxx_binding.cpp`文件编译成可供 V8 引擎执行的 `.node` 文件……也就是说，我们看 `.cpp` 代码 就是在看某个函数是怎么写的……真正的代码执行还是交给了 V8 引擎！我们之所以能让 Node.js 使用其它 C/C++ 写的高性能的库，那是因为我们「封装了一个个`xxx_binding.cpp`（得符合某种要求去写，如需要处理一下类型配对的问题）+编译工具（把`xxx_binding.cpp`编译成 V8 引擎可执行的文件，而不是传统的把`.cpp`交给`C++`编译器去搞）」 -> 我们说的 「C/C++ 扩展」就是 `xxx_binding.cpp`，而「编译过的 C/C++ 扩展」，也就是 V8 引擎能执行的 `xxx.node` -> 文件名：`addon.cc -> addon.node` -> **所谓的高性能的库，我想应该是这个库的代码写得非常好吧！而不是因为用了 C/C++** -> 疑问：Node.js 提供的编译工具真得把所有的 C/C++ 代码都给编译成 `xxx.node`，然后交给 V8 引擎去执行？难道就没有其它线程去编译执行 C/C++ 写的代码？

---

话说，我写 Node.js ，还要会 C++ 吗？

不用会，你**只要知道 JS 和 C/C++ 是如何交互的就行了** -> 大部分人写 Node.js 是不需要会 C++的，而且对于方方来说，方方也不会写 C++代码，只是能看懂，能看懂 C++ 代码在做什么……

---

Node.js 还提供了其它交互方式 -> **只要你能让 JS 去调用 C++ 这件事做好了，那么 JS 的能力就会被无限扩大**

---

8）C/C++ 插件（自定义其它能力）

我们知道 Node.js bindings 的存在 就是为了让 JS 和 C/C++通信 -> Node.js bindings 这个能力使得 Node.js 的能力大大的被扩展了……

那么问题来了

Node.js 提供的这些 bindings 我们可以用的，但是如果有一个新的 C++库，如 xxx 写的关于区块链的库，而 Node.js 并咩有把这个库 binding 进来，你说我们该怎么办呢？

所以 Node.js 就提供了这么一个能力——你可以自己写 C++，然后把这些 C++绑定到 JS 上，然后 JS 就可以调用这些 C++库了

当然，大部分 Node.js 程序员是不会这一块的，即不会为 Node.js 自定义其它的能力！

> 了解一下即可，如果某一天你突然发现自己好像得要去学 C++，那么你就好好看一下这块内容呗！
> 
> 自己写的 C++ ，是不需要用 Node.js 提供的编译工具，编译一下，然后再使用？

接下来，看看 Node.js 的工作流程……

## ★Node.js 工作流程

![Node.js 工作流程](assets/img/2020-08-12-21-41-26.png)

## ★Node.js `v0.10.0` 的 deps 目录

![0.10 的 deps 目录](assets/img/2020-08-12-21-42-53.png)

- deps 目录：在程序里，一般指的是所有依赖……

Node.js 依赖了 7 个 C/C++库 -> **只需要知道 「v8」和「uv」(libuv) 这两个库就行了**！其它的库，只需要了解是干嘛的就行了，如「zlib」是专门用来做压缩用的……

现在最新版的（`v14.8.0`）：

![v14.8.0](assets/img/2020-08-12-21-47-48.png)

## ★libuv & v8 的功能

1）libuv 是什么？

![libuv 是什么](assets/img/2020-08-12-22-41-50.png)

libuv -> lib 是前缀，库名叫「uv」(Unicorn Velociraptor—独角伶盗龙）

![uv](assets/img/2020-08-12-23-18-50.png)

libuv 是怎样诞生的？

诞生的背景：

Ryan 起初想搞一个基于事件驱动、非阻塞 I/O 的 Web 服务器（也叫 Web 处理程序），以达到更高的性能，提供 Apache 等服务器之外的选择。

Ryan 发现每个平台旗下都有各自的 异步 I/O 库，所以 Ryan 觉得自己咩有必要为每个平台都写一个 Node.js 

于是，Ryan 特别机智的就把这些异步 I/O 库整合到一起，然后写了一个库，而这个库就是「libuv」 -> 目的是「写一个**跨平台**的异步 I/O 库」

话说，「I/O」是什么？

所有的输入、输出都属于 I/O，如：

- 写文件 -> 你从你的操作系统上写文件写到硬盘上
- 访问网络 -> 你从你的操作系统发出数据到别人的服务器上
- 打印文档 -> 连接打印机，发份文档给打印机打印
- ……

只要是输入或者输出都属于 I/O 操作！也就是说**系统跟其它的外界进行交互的所有功能都是 I/O** -> 如`readFile()`这个功能与文件系统打交道，所以这是 I/O 操作！

---

libuv 会根据当前系统自动选择已经实现好的 异步 I/O 库！

libuv 的主要功能（所以的功能都是异步的）：

- 可以操作 TCP -> 有啥用？ -> 我们知道 HTTP 是基于 TCP/IP 的，所以只要能操作 TCP，我们就可以做 HTTP 的服务器
- 操作 UDP -> 一般聊天，如 QQ 聊天都是基于 UDP 的，虽然可能会丢包，但不需要三次握手什么的，所以即便不那么稳，但效率还是比较高的！
- 解析 DNS -> 解析 baidu.com 对应哪个 ip，不然怎么知道该向哪个服务器发起请求呢？
- 操作文件 -> 读文件、写文件等这些操作，libuv 都可以帮我们管理！
- ……

有了这些功能，Node.js 就可以摆脱 I/O 瓶颈，即** I/O 全都交给 C/C++来做**，我 JS 一概不管这些功能……我 JS 只负责做一些简单的如调用之类的东西

> 不需要去看 libuv 的源代码……

2）V8 是什么？

![V8](assets/img/2020-08-12-23-55-44.png)

V8 是作者写的第 8 个虚拟机？

> V8 是一个由 Google 开发的开源 JavaScript 引擎，用于 Google Chrome 及 Chromium 中。Lars Bak 是这个项目的组长，以 V8 发动机为其命名 -> 它也被用于服务器端，例如 Couchbase、MongoDB 和 Node.js
> 
> V8 引擎是一个 JavaScript 引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源？
> 
> V8 将 JS 代码编译成**原生机器码**（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript 程序在 V8 引擎下的运行速度媲美二进制程序。

它有哪些功能？

- JS 源代码 -> V8 引擎 -> 机器代码（`0101101……`）「计算机看到这些代码就可以直接执行，不需要再借助任何的其它工具了，就好像我们在 windows 里边双击一个 `xx.exe`文件，然后弹出一个框一样，所以它是非常高效的，目前 V8 是商用里边执行最快的这么一个 JS 引擎」
- 维护 Call Stack -> 这不是 JS 自己维护的，而是所运行的这个 V8 引擎维护的
- 负责内存管理 -> 你 `new Xxx()`，这个对象被存在哪个旮旯是 V8 引擎决定的……
- 辣鸡回收 -> 是为了「重复利用」，而不是「把无用的给清了」…… -> 内存是有限的，必须做辣鸡回收，如你用了 2K 内存，那么你用完了就得还给我，因为我还得给下一个程序用呢！ -> 总之辣鸡回收的目的是为了**重复利用内存**，而不是用了一次，就死在那儿了……就像是上厕所那样，你总不能把这个坑一直蹲到世界末日吧……
- V8 还要实现 JS 的各种标准库，如数组里的`sort/map/filter/reduce`等函数，这些函数都要 V8 自己实现好，不然，JS 就调用不了了，所以 V8 的功能是非常多的……

话说，V8 有这么多功能，那么它是多线程的吗？

是的，它是多线程的，如：

- 它开一个线程执行 JS
- 开一个线程清理内存
- 开一个线程管理其它的东西
- ……

总之，V8 本身是多线程的

注意：

- V8 不提供 DOM API -> 这 DOM API 是浏览器提供的
- V8 执行 JS 的过程是单线程的，注意，**只是执行 JS 是单线程的**！它的内存管理是一个线程，辣鸡回收可能是另一个线程 -> V8 本身是多线程的，可不是单线程的！
- 理论上，可以开两个线程分别执行 JS，这样一来就是多线程执行 JS 了呀！但这并不是真正意义上的多线程，只是开了两个东西去跑 JS 而已，而这两个 JS 毫无瓜葛……
- 辣鸡回收非常复杂，可能不止一个单独线程……
- V8 天生自带 event loop，我们要用它的 event loop 是咩有问题的，但是 Node.js 并咩有用它的，而是自己基于 libuv 自己做了一个 event loop -> 总之，V8 有 event loop，但 Node.js 并没有用，而是自己造了一个

> 知识点：知道 v8 的功能以及 V8 是不是单线程的？

> 浏览器的事件循环是 V8 提供的？ -> 浏览器的事件循环标准是由 HTML 标准规定的，具体来说就是由 whatwg 规定的

---

接下来看看「什么是 event loop？」

## ★EventLoop 简单介绍
